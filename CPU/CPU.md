Контролни сигнали:



- CA - (Това ознчава, че даденият сигнал се изпълнява, когато дойде Clock пулса. Също така това означава, че даденият сигнал трябва да е активен преди да е дошъл Clock Pulse-a)
- TODO: Да видя кои са зависими от Clock Pulse-a и да си ги маркирам.



1. **Clock:**
   - **HALT** (Спира Clock-a, **Halt**)

2. **A Register:**
   - **CLR** (Изтрива записаната стойност в регистъра, **Clear**)
   - **AO** (Пуска сегашно запазената стойност от регистъра на Bus-a, **A Register Output**)
   - **AI** (Запазва стойността, която в момента се намира на Bus-a, **A Register In**, *Active Low*)
3. **B Register:**
   - **CLR** (Изтрива записаната стойност в регистъра, **Clear**)
   - **BO** (Пуска сегашно запазената стойност от регистъра на Bus-a, **B Register Output**)
   - **BI** (Запазва стойността, която в момента се намира на Bus-a, **B Register In**, *Active Low*)
4. **Instruction Register:**
   - **CLR** (Изтрива записаната стойност в регистъра, **Clear**)
   - **IO** (Пуска сегашно запазената стойност от регистъра на Bus-a, **I Register Output**)
   - **II** (Запазва стоността, която в момента се намира на Bus-a, **I Register In**, *Active Low*)

5. **Flags Register:**
   - *Все още не съм го направил!*

6. **ALU:**

   - **EO** (Пуска сегашно записната/пресметната стойност от регистъра на Bus-a, **Enable Output**)
     - При мен мисля, че не е Active Low, защото съм го позиционирал по друг начин

   - **SU** (Изважда стойностите, който са му подадени от регистър A & B, **Subtract**)

7. **RAM:**
   - **PROG** (Сменя между това дали адреса и данните ще идват от Bus-a или от ръчно от DIP Switch-овете, **Program**)
   - **CLR** (Изчиства записаната стойност от регистъра за адреса, **Clear**)
   - **MI** (Дали да се запази избраният адрес,**Memory Address Register In**, *Active Low*)
   - **RO** (Пуска сегашно избраната стойност от адреса в паметта на Bus-a, Ram Output)
     - При мен мисля, че не е Active Low, защото съм го позиционирал по друг начин
   - **RI** (Запазва сегашно избраната стойност на избраният адрес в паметта, **Ram In**)

8. **Program Counter:**
   - **R** (Рестартира брояча, **Reset**, Active Low)
   - **CE** (Паузира брояча. Това е свързка между два сигнала, които ако са HIGH брояча е пуснат, а ако са LOW е паузиран, **Counter Enable**)
   - **J** (Зарежда стойноста от буса в брояча, Как ще го използваме за Jump-a, **Jump**, Active Low)
   - **CO** (Изкарва изброената стойност на буса, **Counter Out**)
     - При мен мисля, че не е Active Low, защото съм го позиционирам по друг начин)

9. **Output Register:**
   - **OI** (Зарежда стойноста от буса в дисплея, **Output In**)





LDA 14 (Зареди данните от 14 адрес от паметта в регистър A)

ADD 15 (Зареди данните от 15 адрес от паметта в регистър A)

OUT



- Ние решаваме как да си кръстим командите, защото ние правим компютъра
- Всяка една команда е запазена в паметта:



LDA 14:

- 0000 адрес
- 0001 1110 данни, където 0001 репрезентира LDA командата, а 1110 репрезентира 14, което е адреса от който искаме да заредим

ADD 15:

- 0001 адрес
- 0010 1111 данни, където 0010 репрезентира ADD командата, а 1111 репрезентира 15, което е адреса от който искаме да заредим

OUT:

- 0010 адрес
- 1110 0000 данни, където 1110 репрезенитира OUT командата, а 0000 нищо.



LDA (Зареди данните от X адрес от паметта в X регистър)



- TODO: Следва да гледам и разписва идеята за контролната логика



- Всичките контролни сигнали ще ги свържа на един Breadboard. Идеята е лесно да контролирам целият компютър от едно място на ръка.

- Някой от контролните сигнали, който са Active Low ще ги обърна.
- Колко още Breadboard-a ще ми трябват, защото на някой места той слага счупени и така има за буса, а аз не ги чупя.

![image-20220714164206082](C:\Users\itsgo\Desktop\GitHub\8-Bit-Computer\Pictures\image-20220714164206082.png)

