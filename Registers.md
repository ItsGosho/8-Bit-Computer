# Registers:

- Повечето **CPU**-та имат **регистри**
- Регистрите запазват **малко количество информация**
- Информация, която се **обработва от процесора**



Във нашият **8-bit** компютър ще имаме **3 бр. регистри**, като **всеки един от тях ще е с големина 8 bit-a**

- Регистри:
- - A - Генерален. Ще го използваме да запазваме каквато и да е информация без конкретно предназначение
  - B - Генерален. Ще го използваме да запазваме каквато и да е информация без конкретно предназначение
  - IR - Instruction Register. Ще го използваме за сегашната инструкция, която се извършва



- Регистрите имат 3 линии за контрол:

  | Операция | Какво прави?                                 |
  | -------- | -------------------------------------------- |
  | Load     | Запазва битовете от входа към регистъра      |
  | Enable   | Изкарва битовете от регистъра към изхода     |
  | Clock    | Извършва избраната операция Load или Enable. |



- Ако искаме да реализираме наш регистър:

- - Може да използваме **D-Flip-Flop**. Той покрива запазването на бит при **Rising Edge** на **Clock** сигнала. (**D Flip Flop.md**)
  - За да постигнем цялото това нещо, трябва да разширим D-Flip-Flop-a, така че да приема данни и запазва, само когато имаме LOAD.
  - **! На снимката EN трябва да е LOAD. Просто съм го объркал ..**.

  <img src="C:\Users\Gosho\Desktop\GitHub\8-bit-Computer\Pictures\image-20220606155512388.png" alt="image-20220606155512388" style="zoom: 50%;" />

  - **Сега изниква друг проблем.** 
  - - Нека запазим 1-ца в регистъра. **LOAD (1)**, **D(1)** и **CLK(1)**
    - След нека извършим следните операции - **EN (0)**, **D(0)** и **CLK(1)**, като това ще разруши нашата запазена 1-ца. 
    - Това се получава, защото при **Inverter-a** от **D сигнала** винаги **имаме HIGH** сигнал
  - Едно решение, което ми изникна беше да сложа **AND GATE** между **CLK** и **LOAD** сигнала.
  - - В крайна сметка след четене из коментарите не намирих добро обяснение, защо това не е добра идея да се използва. Опитах се да разбера как това ще доведе до проблем, но не измислих нищо. Ще го реализирам с Feedback за да видя друг начин за решаване на проблем, който така и не намерих, защото е проблем.
  - Използвах идеята сигнала от **Q** да бъде доставен до **D**, ако няма **LOAD**. Така дори и да се тригърне **CLK**, то ще продължим да пазим същата стойност.
  - <img src=".\Pictures\image-20220607001213286.png" alt="image-20220607001213286" style="zoom: 50%;" />
  - <img src=".\Pictures\image-20220606183518747.png" alt="image-20220606183518747" style="zoom: 50%;" />

- За сега имаме просто един **D Flip Flop** със **Enable** логика



### Ако искаме да свържем регистъра ни към бус лентата:

- Ще имаме проблем, защото постоянно ще изкарва изхода си на буса.
- Ще трябва по някакъв начин да казваме дали стойноста в регистъра да се изкарва на буса. **(Enable)**
- Едно решение, което би ни хрумнало е да свържем резултата на регистъра с **AND** и **Enable**-a. Това ще доведе до проблем, защото ако AND изкарва 0, то ще дърпа Current-a (Sink) и така ако друг регистър иска да изкара 1, то 1-цата ще бъде "засмукана" от регистъра, който изкарва 0 и няма да стигне по-надолу.
- Друг вариант е да имаме нещо, което може да подава сигнал (1, Source), да взима сигна (0, Sink) и да не е свързано към веригата (Z). Това ще ни го свърши Tri-state Buffer-a. 

<img src=".\Pictures\image-20220613003848337.png" alt="image-20220613003848337" style="zoom:67%;" />

- Два 1-битови регистри:

<img src=".\Pictures\image-20220613004341089.png" alt="image-20220613004341089" style="zoom:80%;" />